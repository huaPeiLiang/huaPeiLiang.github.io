---
title: Stream项目-分布式日志
description: 本篇文章将介绍：方案选型、实现、与前台请求进行关联、自动打印TID与requestId、log日志同步skywalking、忽略部分接口
categories:
- 架构之路
---

> 学海无涯，心存高远。

## 方案选型

目前常见的分布式日志解决方案有很多。整个分布式日志需要解决的无非就是以下几点：

- 日志收集
- 日志存储
- 调用链
- 报警
- 展示

最终选择方案：Grafana + SkyWalking + ElasticSearch + logback

## 实现

**SkyWalking集成**

SkyWalking最大的好处就是无侵入代码，但副作用就是有点耗内存。

1. 到官网下载SkyWalking。
2. 修改SkyWalking配置文件，我这边使用的ElasticSearch来存储日志，所以还需要去部署ElasticSearch。
3. 将对应版本的探针放到业务服务器中。
4. JVM参数进行配置。
```
-javaagent:/path/to/skywalking-agent.jar=[option1]=[value1],[option2]=[value2]
```

**TID暴露**

使用logback打印日志，修改logback.xml的日志打印格式，将TID加入日志打印中。示例：


```
<appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
            <layout class="org.apache.skywalking.apm.toolkit.log.logback.v1.x.TraceIdPatternLogbackLayout">
                <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
                <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level logger_name:%logger{36} - [%tid] - message:%msg%n</pattern>
            </layout>
        </encoder>
    </appender>
```

## 与前台请求进行关联

前台发出一个请求，如何获取到TID？上面我们已经将TID在日志中暴露出来了，下面要做的就是通过前台请求找到TID。

**添加requestId**

前台每次发起请求时在header中塞入一个requestId的key，值只要是唯一的就行。这样每次请求就得到了一个类似id的东西（requestId）。

**将requestId与TID关联**

每次请求进来时，SkyWalking都会生成一个唯一的TID。只需要将TID和requestId都在日志中输出，这样就可以通过requestId获取到TID了。

新建一个拦截器，对header中的参数进行拦截，并把数据放入MDC中。示例：

```
public class MDCFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        this.insertIntoMDC(request);

        try {
            chain.doFilter(request, response);
        } finally {
            this.clearMDC();
        }

    }

    @Override
    public void destroy() {

    }

    void insertIntoMDC(ServletRequest request) {
        MDC.put("req.remoteHost", request.getRemoteHost());
        if(request instanceof HttpServletRequest) {
            HttpServletRequest httpServletRequest = (HttpServletRequest)request;
            MDC.put("req.requestURI", httpServletRequest.getRequestURI());
            StringBuffer requestURL = httpServletRequest.getRequestURL();
            if(requestURL != null) {
                MDC.put("req.requestURL", requestURL.toString());
            }

            MDC.put("req.requestId", httpServletRequest.getHeader("RequestId"));
            MDC.put("req.method", httpServletRequest.getMethod());
            MDC.put("req.queryString", httpServletRequest.getQueryString());
            MDC.put("req.userAgent", httpServletRequest.getHeader("User-Agent"));
            MDC.put("req.xForwardedFor", httpServletRequest.getHeader("X-Forwarded-For"));
        }

    }

    void clearMDC() {
        MDC.remove("req.remoteHost");
        MDC.remove("req.requestURI");
        MDC.remove("req.queryString");
        MDC.remove("req.requestURL");
        MDC.remove("req.method");
        MDC.remove("req.userAgent");
        MDC.remove("req.xForwardedFor");
        MDC.remove("req.requestNo");
        MDC.remove("req.ho  stIp");
    }


}
```
修改logback.xml的日志打印格式：


```
<appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
            <layout class="org.apache.skywalking.apm.toolkit.log.logback.v1.x.TraceIdPatternLogbackLayout">
                <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
                <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level logger_name:%logger{36} - [%tid] - RequestId:%X{req.requestId} - message:%msg%n</pattern>
            </layout>
        </encoder>
    </appender>
```

## 自动打印TID与requestId

最后我们需要每个请求过来时都打印一行基础日志，里面包含请求的方法名、TID、requestId。

编写一个Before切面，每次请求controller接口时打印日志，示例：

```
@Aspect
@Component
@Log4j2
public class LogAspect {

    @Before("execution(* com.xxx.controller..*.*(..))")
    public void beforeLog(JoinPoint joinPoint){
        try{
            Signature signature = joinPoint.getSignature();
            log.info("...{}",signature.getName());
        }catch (Exception e){
            ...
        }
    }
}
```

## log日志同步skywalking

skywalking默认是不会记录程序中打印的日志的，如果需要将打印的日志同步到skywalking里面需要进行如下操作：

pom文件引入：

```
<dependency>
    <groupId>org.apache.skywalking</groupId>
    <artifactId>apm-toolkit-logback-1.x</artifactId>
    <version>8.5.0</version>
</dependency>
```

logback文件：

```
<appender name="skywalking-log" class="org.apache.skywalking.apm.toolkit.log.logback.v1.x.log.GRPCLogClientAppender">
    <encoder class="ch.qos.logback.core.encoder.LayoutWrappingEncoder">
        <layout class="org.apache.skywalking.apm.toolkit.log.logback.v1.x.mdc.TraceIdMDCPatternLogbackLayout">
            <pattern>%msg%n</pattern>
        </layout>
    </encoder>
</appender>

<root level="info">
    <appender-ref ref="skywalking-log"/>
</root>
```

修改agent\config配置文件：
```
plugin.toolkit.log.grpc.reporter.server_host=${SW_GRPC_LOG_SERVER_HOST:127.0.0.1}
plugin.toolkit.log.grpc.reporter.server_port=${SW_GRPC_LOG_SERVER_PORT:11800}
plugin.toolkit.log.grpc.reporter.max_message_size=${SW_GRPC_LOG_MAX_MESSAGE_SIZE:10485760}
plugin.toolkit.log.grpc.reporter.upstream_timeout=${SW_GRPC_LOG_GRPC_UPSTREAM_TIMEOUT:30}
```

## 忽略部分接口

项目里面使用了服务的健康监控，所以会有很多“/actuator/health”接口的请求。如果不过滤比较影响使用。

修改agent\config配置文件：
```
trace.ignore_path=${SW_AGENT_TRACE_IGNORE_PATH:/actuator/health/**,/eureka/**,Lettuce/**,Gson/**,Mysql/**}
```




