---
title: Redis字符串
description: 本篇文章将介绍：字符串数据类型的底层实现、SDS与C字符串的区别
categories:
 - Redis
---

> 世界以痛吻我，我仍报之以歌。

## SDS的定义：

```
struct sdshdr {
    // 记录buf数组中已使用字节的数量
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
}
```

## SDS与C字符串的区别：

### 1、获取字符串长度

因为C字符串不记录自身的长度信息，所以获取C字符串的长度
就必须遍历整个字符串，时间复杂度O(N)。

SDS在len属性中记录来SDS本身的长度，所以获取SDS长度时间复杂度O(1)。

### 2、缓冲区溢出

举个例子，假设程序里有两个在内存中紧邻着的C字符串s1和s2，其中s1保存了字符串"Redis"，而s2则保存了字符串"MongoDB"。

如果一个程序员决定通过执行：

```
strcat(s1, " Cluster");
```
将s1的内容修改为"Redis Cluster"，但粗心的他却忘了在执行strcat之前为s1分配足够的空间，那么在strcat函数执行之后，s1的数据将溢出到s2所在的空间中，导致s2保存的内容被意外地修改。

与C字符串不同，SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出问题。

### 3、减少内存分配次数

因为C字符串不记录自身长度，所以对于一个包含了N个字符的C字符串来说，这个C字符串的底层实现总是一个N+1个字符长的数组（额外的一个字符空间用于保存空字符）。所以每次进行新增、缩短操作都需要进行内存重分配。

SDS在每次重新分配内存时都会额外分配空闲的内存，从而降低频繁的内存分配。策略如下：

1、空间预分配

- 如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同。

- 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。

2、惰性空间释放

惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。

### 二进制安全

C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。