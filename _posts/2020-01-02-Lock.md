---
title: Lock
description: 本篇文章将介绍：ReentrantLock完全排他锁、ReentrantReadWriteLock读写锁
categories:
 - 多线程编程
---

> 不积跬步，无以至千里。不积小流，无以成江海。

## ReentrantLock

```
private Lock lock = new ReentrantLock();
```

调用ReentrantLock对象的lock（）方法获取锁，调用unlock（）方法释放锁。

**使用Condition实现等待/通知：错误用法与解决**

关键字synchronized与wait（）和notify（）/notifyAll（）方法相结合可以实现等待/通知模式，类ReentrantLock也可以实现同样的功能，但需要借助于Condition对象。Condition类有更好的灵活性，比如可以实现多路通知功能，也就是在一个Lock对象里面可以创建多个Condition（即对象监视器）实例，线程对象可以注册在指定的Condition中，从而可以有选择性地进行线程通知，在调度线程上更加灵活。(注意：在使用Condition的await()方法之前必须获得锁)

示例：

```
private ReentrantLock lock = new ReentrantLock();
private Condition condition = lock.newCondition();
public void waitMethod() {
    lock.lock();
    condition.await();
    condition.signal();
}
```

Object类中的wait（）方法相当于Condition类中的await（）方法。

Object类中的wait（longtimeout）方法相当于Condition类中的await（longtime，TimeUnit unit）方法。

Object类中的notify（）方法相当于Condition类中的signal（）方法。

Object类中的notifyAll（）方法相当于Condition类中的signalAll（）方法。

**使用多个Condition实现通知部分线程**

示例：

```
public class Myservice{
public Lock lock = new ReentrantLock();
public Condition a = lock.newCondition();
public Condition b = lock.newCondition();
    public void awaitA(){
        lock.lock();
        a.await();
        lock.unlock();
    }
    
    public void awaitB(){
        lock.lock();
        b.await();
        lock.unlock();
    }
    
    public void signalAllA(){
        lock.lock();
        a.signalAll();
        lock.unlock();
    }
    
    public void signalAllB(){
        lock.lock();
        b.signalAll();
        lock.unlock();
    }
}

public class ThreadA extends Thread {
    private Myservice service;
    public ThreadA(MyService service){
        super();
        this.service = service;
    }
    
    public void run(){
        service.awaitA();
    }
}

B线程代码同理

public class Run {
public static void main(String[] args) throws InterruptedException {
    MyService service = new MyService();
    ThreadA a = new ThreadA(service);
    a.setName("A");
    a.start();
    ThreadB b = new ThreadB(service);
    b.setName("B");
    b.start();
    Thread.sleep(3000);
    service.signalAll_A();
}
}
```

结果：

```
只有A线程被唤醒
```

**公平锁和非公平锁**


```
公平锁：
public Lock lock = new ReentrantLock(true);
非公平锁：
public Lock lock = new ReentrantLock(false);
```

**其他方法**

1、方法int getHoldCount（）的作用是查询当前线程保持此锁定的个数，也就是调用lock（）方法的次数。

2、方法int getQueueLength（）的作用是返回正等待获取此锁定的线程估计数，比如有5个线程，1个线程首先执行await（）方法，那么在调用getQueueLength（）方法后返回值是4，说明有4个线程同时在等待lock的释放。

3、方法int getWaitQueueLength（Condition condition）的作用是返回等待与此锁定相关的给定条件Condition的线程估计数，比如有5个线程，每个线程都执行了同一个condition对象的await（）方法，则调用getWaitQueueLength（Condition condition）方法时返回的int值是5。

4、方法boolean hasQueuedThread（Thread thread）的作用是查询指定的线程是否正在等待获取此锁定。

5、方法boolean hasWaiters（Condition condition）的作用是查询是否有线程正在等待与此锁定有关的condition条件。

6、方法boolean isFair（）的作用是判断是不是公平锁。

7、方法boolean isHeldByCurrentThread（）的作用是查询当前线程是否保持此锁定。

8、方法boolean isLocked（）的作用是查询此锁定是否由任意线程保持。

9、方法boolean tryLock（）的作用是，仅在调用时锁定未被另一个线程保持的情况下，才获取该锁定。

10、方法boolean tryLock（long timeout，TimeUnit unit）的作用是，如果锁定在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁定。

## ReentrantReadWriteLock

类ReentrantLock具有完全互斥排他的效果，即同一时间只有一个线程在执行ReentrantLock.lock（）方法后面的任务。这样做虽然保证了实例变量的线程安全性，但效率却是非常低下的。所以在JDK中提供了一种读写锁ReentrantReadWriteLock类，使用它可以加快运行效率。读写锁表示也有两个锁，一个是读操作相关的锁，也称为共享锁；另一个是写操作相关的锁，也叫排他锁。也就是多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥。在没有线程Thread进行写入操作时，进行读取操作的多个Thread都可以获取读锁，而进行写入操作的Thread只有在获取写锁后才能进行写入操作。即多个Thread可以同时进行读取操作，但是同一时刻只允许一个Thread进行写入操作。

**获取读锁(不互斥)**
```
private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
lock.readLock().lock();
lock.readLock.unlock();
```

**获取写锁（互斥）**

```
private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
lock.writeLock().lock();
lock.writeLock.unlock();
```

**互斥规则**

读读不互斥

写写互斥

读写互斥

写读互斥