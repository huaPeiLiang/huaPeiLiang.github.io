---
title: Fork Join工作窃取队列

description: 本篇文章将介绍：工作窃取队列的简介、如何工作的、特点、扩容
categories:
 - 多线程编程
---

> 不积跬步，无以至千里。不积小流，无以成江海。

## 简介

它并非使用BlockingQueue，而是基于一个普通的数组得以实现。

所谓工作窃取算法，是指一个Worker线程在执行完毕自己队列中的任务之后，可以窃取其他线程队列中的任务来执行，从而实现负载均衡，以防有的线程很空闲，有的线程很忙。这个过程要用到工作窃取队列。

## 如何工作的

1、Worker线程自己，在队列头部，通过对queueTop指针执行加、减操作，实现入队或出队，这是单线程的。

2、其他Worker线程，在队列尾部，通过对queueBase进行累加，实现出队操作，也就是窃取，这是多线程的，需要通过CAS操作。

注意：queueTop不是volatile类型，queueBase是volatile类型。

## 特点

- 整个队列是环形的，也就是一个数组实现的RingBuffer。并且queueBase会一直累加，不会减小；queueTop会累加、减小。最后，queueBase、queueTop的值都会大于整个数组的长度，只是计算数组下标的时候，会取queueTop&（queue.length-1），queueBase&（queue.length-1）。因为queue.length是2的整数次方，这里也就是对queue.length进行取模操作。

当queueTop-queueBase=queue.length-1的时候，队列为满，此时需要扩容；

当queueTop=queueBase的时候，队列为空，Worker线程即将进入阻塞状态。

- 当队列满了之后会扩容，所以被称为是动态的。

## 扩容

在queueBase一端，是多线程访问的，但它们只会使queueBase变大，也就是使队列中的元素变少。所以队列为满，一定发生在queueTop一端，对queueTop进行累加的时候，这一端却是单线程的！队列的扩容恰好利用了这个单线程的特性！即在扩容过程中，不可能有其他线程对queueTop进行修改，只有线程对queueBase进行修改！