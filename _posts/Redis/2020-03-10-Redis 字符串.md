---
title: Redis 字符串
description: 本篇文章将介绍：字符串数据类型的底层实现、SDS 与 C 字符串的区别
categories:
 - Redis
---

> 世界以痛吻我，我仍报之以歌。

## SDS 的定义：

```
struct sdshdr {
    // 记录buf数组中已使用字节的数量
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
}
```

## SDS 与 C 字符串的区别：

### 1、获取字符串长度

因为 C 字符串不记录自身的长度信息，所以获取 C 字符串的长度
就必须遍历整个字符串，时间复杂度O(N)。

SDS 在 len 属性中记录来 SDS 本身的长度，所以获取 SDS 长度时间复杂度O(1)。

### 2、缓冲区溢出

举个例子，假设程序里有两个在内存中紧邻着的C字符串 s1 和 s2，其中 s1 保存了字符串"Redis"，而 s2 则保存了字符串"MongoDB"。

如果一个程序员决定通过执行：

```
strcat(s1, " Cluster");
```
将 s1 的内容修改为"Redis Cluster"，但粗心的他却忘了在执行 strcat 之前为 s1 分配足够的空间，那么在 strcat 函数执行之后，s1 的数据将溢出到 s2 所在的空间中，导致 s2 保存的内容被意外地修改。

与 C 字符串不同，SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当 SDS API 需要对 SDS 进行修改时，API 会先检查 SDS 的空间是否满足修改所需的要求，如果不满足的话，API 会自动将 SDS 的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用 SDS 既不需要手动修改 SDS 的空间大小，也不会出现前面所说的缓冲区溢出问题。

### 3、减少内存分配次数

因为 C 字符串不记录自身长度，所以对于一个包含了 N 个字符的 C 字符串来说，这个 C 字符串的底层实现总是一个 N+1 个字符长的数组（额外的一个字符空间用于保存空字符）。所以每次进行新增、缩短操作都需要进行内存重分配。

SDS 在每次重新分配内存时都会额外分配空闲的内存，从而降低频繁的内存分配。策略如下：

1、空间预分配

- 如果对 SDS 进行修改之后，SDS 的长度（也即是 len 属性的值）将小于1MB，那么程序分配和 len 属性同样大小的未使用空间，这时 SDS len 属性的值将和 free 属性的值相同。

- 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间。

2、惰性空间释放

惰性空间释放用于优化 SDS 的字符串缩短操作：当 SDS 的 API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来使用。

### 二进制安全

C 字符串中的字符必须符合某种编码（比如 ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得 C 字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。