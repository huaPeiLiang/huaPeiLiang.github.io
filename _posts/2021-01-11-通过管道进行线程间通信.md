---
title: 通过管道进行线程间通信

description: 本篇文章将介绍：管道通信简介、PipedInputStream 和 PipedOutputStream 实现线程通信示例
categories:
 - 多线程编程
---

> 不积跬步，无以至千里。不积小流，无以成江海。

## 简介

在 Java 语言中提供了各种各样的输入/输出流 Stream，使我们能够很方便地对数据进行操作，其中管道流（pipeStream）是一种特殊的流，用于在不同线程间直接传送数据。一个线程发送数据到输出管道，另一个线程从输入管道中读数据。通过使用管道，实现不同线程间的通信，而无须借助于类似临时文件之类的东西。在Java的JDK中提供了4个类来使线程间可以进行通信：

1、 PipedInputStream 和 PipedOutputStream

2、 PipedReader 和 PipedWriter

## PipedInputStream 和 PipedOutputStream 实现线程通信示例：

首先创建一个写入字节流（PipedOutputStream）方法
```
public class WirteData {
    public void writeMethod(PipedOutputStream out) {
        try{
            System.out.println("write :");
            out.write("1234567890");
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
然后创建一个读取字节流（PipedInputStream）方法
```
public class ReadData {
    public void readMethod(PipedInputStream input) {
        try{
            System.out.println("read :");
            byte[] byteArray = new byte[10];
            int readLength = input.read(byteArray);
            while (readLength != -1) {
                String newData = new String(byteArray, 0, readLength);
                System.out.println(newData);
                readLength = input.read(readLength);
            }
            input.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
定义两个线程
```
public class ThreadWrite extends Thread {
    private WriteData write;
    private PipedOutputStream out;
    
    public ThreadWrite(WriteData write, PipedOutputStream out){
        super();
        this.write = write;
        this.out = out;
    }
    
    public void run(){
        write.writeMethod(out);
    }
}
```

```
public class ThreadRead extends Thread {
    private ReadData read;
    private PipedInputStream input;
    
    public ThreadWrite(ReadData read, PipedInputStream input){
        super();
        this.read = read;
        this.input = input;
    }
    
    public void run(){
        read.readMethod(input);
    }
}
```
最后创建执行类
```
public class Run {
    public static void main(String[] args){
        try{
            WriteData writeData = new WriteData();
            ...
            outputStream.commect(inputStream);
            ThreadRead threadRead = new ThreadRead(readData, inputStream);
            threadRead.start();
            Thread.sleep(2000);
            ThreadWrite threadWrite = new ThreadWrite(writeData, outputStream);
            threadWrite.start();
        } catch (Exception e){
            ...
        }
    }
}
```
使用代码 inputStream.connect（outputStream）或 outputStream.connect（inputStream）的作用使两个 Stream 之间产生通信链接，这样才可以将数据进行输出与输入。

运行结果：
```
read :
write :
1234567890
1234567890
```
但在此实验中，首先是读取线程 new ThreadRead（inputStream）启动，由于当时没有数据被写入，所以线程阻塞在 int readLength=input.read（byteArray）；代码中，直到有数据被写入，才继续向下运行。
